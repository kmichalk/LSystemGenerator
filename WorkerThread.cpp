#include "WorkerThread.h"



WorkerThread::WorkerThread():
	finished(false),
	jobCheckInterval(DEFAUTL_JOB_CHECK_INTERVAL),
	job(nullptr)
{
}

///////////////////////////////////////////////////////////////////////////////////////////////

WorkerThread::~WorkerThread() {
}

///////////////////////////////////////////////////////////////////////////////////////////////

void WorkerThread::run() {
	running = true;
	while (running) {
		process();
		_sleep(jobCheckInterval);
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////

void WorkerThread::process() {
	if (job != nullptr) {
		jobLock.lock();
		Job* prev = job;
		job = nullptr;
		jobLock.unlock();
		prev->execute();
		finished = true;
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////

//void WorkerThread::finish() {
//	while(!finished){}
//}

///////////////////////////////////////////////////////////////////////////////////////////////

void WorkerThread::finish(int checkInterval) {
	if (checkInterval == 0)
		while (!finished){}
	else
		while (!finished)
			_sleep(checkInterval);	
	
}

///////////////////////////////////////////////////////////////////////////////////////////////

bool WorkerThread::hasFinished() const {
	return finished;
}

///////////////////////////////////////////////////////////////////////////////////////////////

void WorkerThread::setJobCheck(int ms) {
	jobCheckInterval = ms;
}

///////////////////////////////////////////////////////////////////////////////////////////////

void WorkerThread::setJob(Job * job) {
	jobLock.lock();
	finished = false;
	this->job = job;
	jobLock.unlock();
}
